# WARNING - Generated by {fusen} from dev/flat_full.Rmd: do not edit by hand # nolint: line_length_linter.


#' A wrapper for `readr`'s `read_csv` & `readxl`'s `read_excel` for reading trial data
#'
#' @param dir trial data home directory
#' @param season trial season
#' @param read_subfolder logical. `TRUE` if data lives inside a subfolder in `season`
#' @param s a regular expression used to keep relevant files
#' @param sub_folder character of subfolder containing data e.g `"Data/Curated Data"`
#' @param subset ogical. `TRUE` if you want to read just a subset of files
#' @param n integer. Number of files to subset e.g, `1`, `-1` `1:4`.
#' @param multiple logical. `TRUE` if you want to read nultiple excel sheets from the same workbook
#' @param sheet_name character. used to specify excel sheet name of interest, e.g., `"fieldbook"`
#' @param skip integer. number of rows to skip when reading data from an excel workbook
#' @param file_to_read character.file name to read e.g., generated by `system.file()`
#' @param merge clogical. whether or not to merge data from multiple sheets 
#'
#' @return a list of trial dataframes
#' @export
#'
#' @examples
#' f <- system.file("uon-trial-1.csv", package = "pbwrangler")
#' d <- read_workbooks(dir = NULL, file_to_read = f)
#' lapply(d, function(x) x[1:5, 1:5])
read_workbooks <- function(dir = t_dir
                           ,season = NULL
                           ,read_subfolder = FALSE
                           ,s = ".csv|.xlsx"
                           ,sub_folder = "Data/Curated Data"
                           ,subset = FALSE
                           ,n = NULL
                           ,multiple = FALSE
                           ,sheet_name = NULL
                           ,skip = 0
                           ,file_to_read = NULL
                           ,merge = FALSE
                           ) {
  
  if(is.null(season)){
    folders = file.path(dir)
  }else{
    folders = file.path(dir, season)
  }
  # a situation where you want to read system files
  if(is.null(dir)){
    if(is.null(file_to_read)) {
      stop("file_to_read must be specified and not NULL if dir is NULL")
    }else{
      file <- file_to_read
    }
  } else if (isTRUE(read_subfolder)) {
    file <- list_files(folder = file.path(folders, sub_folder), subset = subset, n = n, s = s) %>%
       subset(., grepl(s, .)
      ) %>% subset(.,
                   !grepl("mult|layout|plant|seed|regro|meta", gsub(".*/", "", .), ignore.case = TRUE))
  } else{
    file <- list_files(folder = folders, subset = subset, n = n, s = s) %>%
      subset(., grepl(s, .)
      ) %>% subset(.,
                   !grepl("mult|layout|plant|seed|regro|meta", gsub(".*/", "", .), ignore.case = TRUE))
  }
  # n must be specified if subset TRUE
  if(isTRUE(subset) & is.null(n)) stop("n must be specified if subset = TRUE")
  

  # if(dir == m_dir){
  #   file <- list.files(dir, full.names = TRUE) %>%
  #     # look at this subsetting `[`
  #     subset(., grepl("season", ., ignore.case = TRUE))
  # }
  
  
  if (length(file) > 0) {
    # file .xlsx or .csv
    
    f_csv <- file[grepl("csv", file)]
    f_xls <- file %>% subset(., !file %in% f_csv)
    
    
    # for .csvs
    # duplicate column names for Njoro (ntp, plant_unif, se, nmtci/ii, mtwci/ii)
    # to do: investigate
    if (length(f_csv) > 0) {
      if (!isTRUE(read_subfolder)) {
        f_names_2 <- toupper(clean_dir_name(f_csv))
      } else{
        f_names_2 <- toupper(clean_dir_name_c(f_csv))
      }
      out_csv <-
        purrr::map(f_csv, readr::read_csv) %>% magrittr::set_names(f_names_2) %>% purrr::map(., janitor::clean_names)
      out_csv <- purrr::map(out_csv, drop_nas) %>%
      # %>% purrr::map(
      #   ., ~ dplyr::mutate(., across(any_of("plot"), ~ as.character()))
      # )
        purrr::map(., data.frame)
    }
    if (length(f_xls) > 0) {
      
      if (!isTRUE(read_subfolder)) {
        f_names <- toupper(clean_dir_name(f_xls))
      } else{
        f_names <- toupper(clean_dir_name_c(f_xls))
      }
      
      if(isTRUE(multiple)){
        sheets <- purrr::map(f_xls, readxl::excel_sheets)
        sheets <- purrr::map(sheets, drop_sheets)

        
        # drop files without data - changed to >= from ==
        f_xls <- f_xls[which(sapply(sheets, length) >= 1)]
        sheets <- sheets[which(sapply(sheets, length) >= 1)]
        
        # drop empty list elements
        sheets <- sheets[!sapply(sheets, identical, character(0))]
        
        out_xls <- vector("list", length = length(f_xls)) %>% purrr::set_names(f_names)
        
        for (i in seq_along(f_xls)) {
          d <-
            purrr::map2(f_xls[i], sheets[[i]], readxl::read_excel, skip = skip) %>%
            purrr::set_names(sheets[[i]]) %>%
            purrr::map(., janitor::clean_names) %>% purrr::map(
              ., ~ dplyr::mutate(
                ., across(any_of("plot"), ~ as.character(.))
              )
            )
          if (isTRUE(merge)) {
            out_xls[[i]] <- purrr::reduce(d, dplyr::left_join, by = "plot")
          } else{
            out_xls[[i]] <- d
          }
        }
        
        # read multiple sheets 
        # out_xls <- sheets %>%  unlist() %>% 
        #   purrr::map(~readxl::read_excel(path = f_xls, skip = skip)) %>% magrittr::set_names(., unlist(sheets))
        
        # x <- tibble::data_frame(path = f_xls, sheet = sheets)
        # x <- tidyr::unnest(x)
        # 
        # out_xls <- x %>% purrr::map2(
        #   path, sheet,
        #   ~readxl::read_excel(.x, .y)
        # )
        
        # out_xls <-  purrr::map2(
        #   x$path, x$sheet,
        #   ~readxl::read_excel(.x, .y)
        # )

        # out_xls <- sheets %>% unlist() %>% purrr::set_names() %>% 
        #   purrr::map(readxl::read_excel,path = f_xls, skip = skip) 

      }
      # check if reading multiple sheets from same workbook and sheet_name specified
      
      if (!isTRUE(multiple)){
        if(!is.null(sheet_name)){
          sheets = purrr::map(f_xls, readxl::excel_sheets) %>%
            purrr::map(., function(x) grep(sheet_name, x, ignore.case = T, value = T))

        }else {
          sheets = purrr::map(f_xls, readxl::excel_sheets) %>% purrr::map(., drop_sheets)

        }
        
        out_xls <- purrr::map2(f_xls, sheets, readxl::read_excel, skip = skip) %>% 
          magrittr::set_names(., f_names) %>% purrr::map(
            ., ~ dplyr::mutate(., across(any_of("plot"), ~ as.character(.)))
          )
      }

      out_xls <- purrr::map(out_xls, drop_nas) #%>% set_names(., f_names)
      out_xls <-
        out_xls %>% purrr::map(., janitor::clean_names) %>% purrr::map(., data.frame)
      # map(out_xls, names_df)
    }
    
    
    # unnest lists
    if (exists("out_xls") & exists("out_csv")) {
      out <- c(out_csv, out_xls)
    } else if (exists("out_xls") & !exists("out_csv")) {
      out <- out_xls
    } else {
      out <- out_csv
    }
    # list2env(out, envir = .GlobalEnv)
    # rename a column if it exists
    out <- purrr::map(out, ~ dplyr::rename_with(
      .,
      ~ dplyr::case_when(
        grepl("column", ., ignore.case = TRUE) ~ "col",
        grepl("site", ., ignore.case = TRUE) ~ "loc",
        grepl("nph_1_present_0_absent", ., ignore.case = TRUE) ~ "nph",
        grepl("clone|^variet|instn", ., ignore.case = TRUE) ~ "geno",
        grepl("^uniqueid|unique_id", ., ignore.case = TRUE) ~ "unique_id",
        TRUE ~ .
      )
    ))
    # coerce type
    out <- out %>%
      purrr::map(., ~ dplyr::mutate(., across(any_of(
        c(
          'se',
          'tuber_apper',
          'tub_unif',
          'tub_size',
          'ntp',
          'plant_vigor',
          'mtwci',
          'mtwcii',
          'nmtci',
          'nmtcii',
          'nnomtp',
          'nomtwp',
          'npe',
          'overall_impression'
        )
      ), ~ as.numeric(.)))) %>% purrr::map(., ~ dplyr::mutate(., across(any_of(
        c('flowering_date')
      ), ~ as.character(.))))
    # delete columns without a name assigned
    
    out <- out %>% purrr::map(
      ., ~ dplyr::mutate(
        ., across(any_of(
          c(
  "x30_35_number",
  "x35_40_number",
  "x40_45_number",
  "x45_50_number",
  "x50_55_number",
  "x55_60_number",
  "x60_65_number",
  "x65_70_number",
  "x70_number",
  "x0_10_number",
  "x0_30_number",
  "weight_g_60_65",
  "weight_g_65_70",
  "weight_g_70",
  "weight_g_30_35",
  "weight_g_35_40",
  "weight_g_40_45",
  "weight_g_45_50",
  "weight_g_50_55",
  "weight_g_55_60",
  "weight_g_0_10",
  "weight_g_10_30"
  
)
        ), ~ ifelse(. < 0, NA, .))
      )
    )
    # out <- out %>% purrr::map(., ~ dplyr::select(., !grep("^x", names(.), ignore.case = TRUE)))
    out <- out %>% #compute_cols(.) %>%
      purrr::map(., data.frame)
    # clean names
    # names(out) <- gsub("*_\\d+", "", names(out))
    return(out)
  } else{
    message("No data to read!")
  }
  
}
