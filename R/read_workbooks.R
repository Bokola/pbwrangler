# WARNING - Generated by {fusen} from dev/flat_full.Rmd: do not edit by hand # nolint: line_length_linter.


#' A wrapper for `readr`'s `read_csv` & `readxl`'s `read_excel` for reading trial data
#'
#' @param dir trial data home directory
#' @param season trial season
#' @param read_subfolder logical. `TRUE` if data lives inside a subfolder in `season`
#' @param s a regular expression used to keep relevant files
#' @param sub_folder character of subfolder containing data e.g `"Data/Curated Data"`
#' @param subset ogical. `TRUE` if you want to read just a subset of files
#' @param n integer. Number of files to subset e.g, `1`, `-1` `1:4`.
#' @param multiple logical. `TRUE` if you want to read nultiple excel sheets from the same workbook
#' @param sheet_name character. used to specify excel sheet name of interest, e.g., `"fieldbook"`
#' @param skip integer. number of rows to skip when reading data from an excel workbook
#' @param file_to_read character.file name to read e.g., generated by `system.file()`
#'
#' @return a list of trial dataframes
#' @export
#'
#' @examples
#' f <- system.file("uon-trial-1.csv", package = "pbwrangler")
#' d <- read_workbooks(dir = NULL, file_to_read = f)
#' lapply(d, function(x) x[1:5, 1:5])
read_workbooks <- function(dir = t_dir
                           ,season = NULL
                           ,read_subfolder = FALSE
                           ,s = ".csv|.xlsx"
                           ,sub_folder = "Data/Curated Data"
                           ,subset = FALSE
                           ,n = NULL
                           ,multiple = FALSE
                           ,sheet_name = NULL
                           ,skip = 0
                           ,file_to_read = NULL
                           ) {
  
  if(is.null(season)){
    folders = file.path(dir)
  }else{
    folders = file.path(dir, season)
  }
  # a situation where you want to read system files
  if(is.null(dir)){
    if(is.null(file_to_read)) {
      stop("file_to_read must be specified and not NULL if dir is NULL")
    }else{
      file <- file_to_read
    }
  } else if (isTRUE(read_subfolder)) {
    file <- list_files(folder = file.path(folders, sub_folder), subset = subset, n = n, s = s) %>%
       subset(., grepl(s, .)
      ) %>% subset(.,
                   !grepl("mult|layout|plant|seed|regro|meta", ., ignore.case = TRUE))
  } else{
    file <- list_files(folder = folders, subset = subset, n = n, s = s) %>%
      subset(., grepl(s, .)
      ) %>% subset(.,
                   !grepl("mult|layout|plant|seed|regro|meta", ., ignore.case = TRUE))
  }
  # n must be specified if subset TRUE
  if(isTRUE(subset) & is.null(n)) stop("n must be specified if subset = TRUE")
  

  # if(dir == m_dir){
  #   file <- list.files(dir, full.names = TRUE) %>%
  #     # look at this subsetting `[`
  #     subset(., grepl("season", ., ignore.case = TRUE))
  # }
  
  
  if (length(file) > 0) {
    # file .xlsx or .csv
    
    f_csv <- file[grepl("csv", file)]
    f_xls <- file %>% subset(., !file %in% f_csv)
    
    
    # for .csvs
    # duplicate column names for Njoro (ntp, plant_unif, se, nmtci/ii, mtwci/ii)
    # to do: investigate
    if (length(f_csv) > 0) {
      if (!isTRUE(read_subfolder)) {
        f_names_2 <- clean_dir_name(f_csv)
      } else{
        f_names_2 <- clean_dir_name_c(f_csv)
      }
      out_csv <-
        purrr::map(f_csv, readr::read_csv) %>% magrittr::set_names(f_names_2) %>% purrr::map(., janitor::clean_names)
      out_csv <- purrr::map(out_csv, drop_nas) %>% purrr::map(., data.frame)
    }
    if (length(f_xls) > 0) {
      
      if (!isTRUE(read_subfolder)) {
        f_names <- clean_dir_name(f_xls)
      } else{
        f_names <- clean_dir_name_c(f_xls)
      }
      
      if(isTRUE(multiple)){
        sheets <- purrr::map(f_xls, readxl::excel_sheets)
        sheets <- purrr::map(sheets, drop_sheets)

        
        # drop files without data - changed to >= from ==
        f_xls <- f_xls[which(sapply(sheets, length) >= 1)]
        sheets <- sheets[which(sapply(sheets, length) >= 1)]
        
        # drop empty list elements
        sheets <- sheets[!sapply(sheets, identical, character(0))]
        
        # read multiple sheets 
        out_xls <- sheets %>%  unlist() %>% 
          purrr::map(~readxl::read_excel(path = f_xls, skip = skip)) %>% magrittr::set_names(., unlist(sheets))
      }
      # check if reading multiple sheets from same workbook and sheet_name specified
      
      if (!isTRUE(multiple)){
        if(!is.null(sheet_name)){
          sheets = purrr::map(f_xls, readxl::excel_sheets) %>%
            purrr::map(., function(x) grep(sheet_name, x, ignore.case = T, value = T))

        }else {
          sheets = purrr::map(f_xls, readxl::excel_sheets) %>% purrr::map(., drop_sheets)

        }
        
        out_xls <- purrr::map2(f_xls, sheets, readxl::read_excel, skip = skip) %>% magrittr::set_names(., f_names)
      }

      out_xls <- purrr::map(out_xls, drop_nas) #%>% set_names(., f_names)
      out_xls <-
        out_xls %>% purrr::map(., janitor::clean_names) %>% purrr::map(., data.frame)
      # map(out_xls, names_df)
    }
    
    
    # unnest lists
    if (exists("out_xls") & exists("out_csv")) {
      out <- c(out_csv, out_xls)
    } else if (exists("out_xls") & !exists("out_csv")) {
      out <- out_xls
    } else {
      out <- out_csv
    }
    # list2env(out, envir = .GlobalEnv)
    # rename a column if it exists
    out <- purrr::map(out, ~ dplyr::rename_with(
      .,
      ~ dplyr::case_when(
        grepl("column", ., ignore.case = TRUE) ~ "col",
        grepl("site", ., ignore.case = TRUE) ~ "loc",
        grepl("nph_1_present_0_absent", ., ignore.case = TRUE) ~ "nph",
        grepl("clone|^variet|instn", ., ignore.case = TRUE) ~ "geno",
        grepl("^uniqueid|unique_id", ., ignore.case = TRUE) ~ "unique_id",
        TRUE ~ .
      )
    ))
    # coerce type
    out <- out %>%
      purrr::map(., ~ dplyr::mutate(., across(any_of(
        c(
          'se',
          'tuber_apper',
          'tub_unif',
          'tub_size',
          'ntp',
          'plant_vigor',
          'mtwci',
          'mtwcii',
          'nmtci',
          'nmtcii',
          'nnomtp',
          'nomtwp',
          'npe',
          'overall_impression'
        )
      ), ~ as.numeric(.)))) %>% purrr::map(., ~ dplyr::mutate(., across(any_of(
        c('flowering_date')
      ), ~ as.character(.))))
    # delete columns without a name assigned
    out <- out %>% purrr::map(., ~ dplyr::select(., !grep("^x", names(.), ignore.case = TRUE)))
    out <- out %>% purrr::map(., data.frame)
    # clean names
    # names(out) <- gsub("*_\\d+", "", names(out))
    return(out)
  } else{
    message("No data to read!")
  }
  
}
